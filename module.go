package main

import (
	"text/template"

	pgs "github.com/lyft/protoc-gen-star/v2"
	pgsGo "github.com/lyft/protoc-gen-star/v2/lang/go"
)

// Redactor returns the implementation of the protoc-gen-redact plugin
// to generate redaction file
func Redactor() pgs.Module { return &Module{ModuleBase: &pgs.ModuleBase{}} }

// Module implements the pgs.Module interface for protoc-gen-redact plugin
type Module struct {
	*pgs.ModuleBase
	ctx  pgsGo.Context
	tmpl *template.Template
}

// Name...
func (*Module) Name() string { return "redactor" }

// InitContext satisfies the pgs.Module interface and helps build the module
func (m *Module) InitContext(c pgs.BuildContext) {
	m.ModuleBase.InitContext(c)
	m.ctx = pgsGo.InitContext(c.Parameters())

	tpl := template.New("redact").Funcs(map[string]interface{}{
		"package": m.ctx.PackageName,
		"name":    m.ctx.Name,
	})

	m.tmpl = template.Must(tpl.Parse(redactTpl))
}

// Execute satisfies the pgs.Module interface & generates the redactor file
// for the targeted files
func (m *Module) Execute(targets map[string]pgs.File, _ map[string]pgs.Package) []pgs.Artifact {
	// process all the target files
	for _, file := range targets {
		m.Process(file)
	}
	return m.Artifacts()
}

const redactTpl = `{{ $data := . }}
// Code generated by protoc-gen-redact. DO NOT EDIT.
// source: {{ $data.Source }}

package {{ $data.Package }}

import (
	{{- range $alias, $path := $data.Imports }}
	{{ $alias }} "{{ $path }}"
	{{- end }}
)

// Reference imports to suppress errors if they are not otherwise used.
var (
	{{- range $name := $data.References }}
	_ {{ $name }}
	{{- end }}
)

{{ range $srv := $data.Services }}
	{{- if $srv.Skip }}
		// Redacted server wrapper for {{ $srv.Name }} is skipped
		var RegisterRedacted{{ $srv.Name }} = Register{{ $srv.Name }}
	{{- else }}
		// RegisterRedacted{{ $srv.Name }} wraps the {{ $srv.Name }} with the redacted server and registers the service in GRPC
		func RegisterRedacted{{ $srv.Name }}(s grpc.ServiceRegistrar, srv {{ $srv.Name }}, bypass redact.Bypass) {
			Register{{ $srv.Name }}(s, Redacted{{ $srv.Name }}(srv, bypass))
		}

		func Redacted{{ $srv.Name }}(srv {{ $srv.Name }}, bypass redact.Bypass) {{ $srv.Name }} {
			if bypass == nil {
				bypass = redact.Falsy
			}
			return &redacted{{ $srv.Name }}{srv: srv, bypass: bypass}
		}

		type redacted{{ $srv.Name }} struct {
			Unsafe{{ $srv.Name }}
			srv    {{ $srv.Name }}
			bypass redact.Bypass
		}

		{{ range $meth := $srv.Methods }}
			// {{ $meth.Name }} is the redacted wrapper for the actual {{ $srv.Name }}.{{ $meth.Name }} method
			func (s *redacted{{ $srv.Name }}) {{ $meth.Name }}(ctx context.Context, in *{{ $meth.Input }}) (*{{ $meth.Output.WithAlias }}, error) {
				{{- if $meth.Skip }}
					// Redaction skipped
					return s.srv.{{ $meth.Name }}(ctx, in)
				{{- else if $meth.Internal }}
					if s.bypass.CheckInternal(ctx) {
						return s.srv.{{ $meth.Name }}(ctx, in)
					}
					return nil, status.Error(codes.{{ $meth.StatusCode }}, {{ $meth.ErrMessage }})
				{{- else }}
					res, err := s.srv.{{ $meth.Name }}(ctx, in)
					if !s.bypass.CheckInternal(ctx) {
						{{- if $meth.Output.ToNil }}
							// Response message is set to nil, ignoring all field level rules
							res = nil
						{{- else if $meth.Output.ToEmpty }}
							// Response message is set to empty, ignoring all field level rules
							res = &{{ $meth.Output.WithAlias }}{}
						{{- else if $meth.Output.Ignore  }}
							// Response message is set to be ignored from any redaction
						{{- else }}
							// Apply redaction to the response
							redact.Apply(res)
						{{- end }}
					}
					return res, err
				{{- end }}
			}
		{{ end }}
	{{ end }}
{{ end }}

{{ range $msg := $data.Messages }}
	// Redact method implementation for {{ $msg.Name }}
	func (x *{{ $msg.Name }}) Redact() string {
		{{- if $msg.Ignore }}
			// Ignoring message
		{{- else if $msg.ToEmpty }}
			// Message will be set to empty, ignoring all field level rules
		{{- else if $msg.ToNil }}
			// Message will be set to nil, ignoring all field level rules
		{{- else }}
			if x == nil { return "" }
			{{- range $field := $msg.Fields }}
				{{ if $field.Redact }}
					// Redacting field: {{ $field.Name }}
					{{- if $field.Iterate }}
						{{- if $field.NestedEmbedCall }}
							for k := range x.{{ $field.Name }} {
								redact.Apply(x.{{$field.Name}}[k])
							}
						{{- else if $field.EmbedSkip }}
							// {{$field.Name}} redaction is skipped
                        {{- else }}
							for k := range x.{{ $field.Name }} {
								x.{{ $field.Name }}[k] = {{ $field.RedactionValue }}
							}
						{{- end }}
                    {{- else if $field.IsMessage }}
						{{- if $field.NestedEmbedCall }}
							redact.Apply(x.{{$field.Name}})
						{{- else if $field.EmbedSkip }}
							// {{$field.Name}} redaction is skipped
                        {{- else }}
							x.{{ $field.Name }} = {{ $field.RedactionValue }}
						{{- end }}
                    {{- else }}
						x.{{ $field.Name }} = {{ $field.RedactionValue }}
					{{- end }}
				{{- else }}
					// Safe field: {{ $field.Name }}
				{{- end }}
			{{- end }}
		{{- end }}
    return x.String()
	}
{{ end }}
`
